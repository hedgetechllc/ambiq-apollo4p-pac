#[doc = "Register `AUTO` reader"]
pub type R = crate::R<AutoSpec>;
#[doc = "Register `AUTO` writer"]
pub type W = crate::W<AutoSpec>;
#[doc = "If memory multiple block data transfer is not started due to command error, this bit is not set because it is not necessary to issue Auto CMD12. Setting this bit to 1 means the HC cannot issue Auto CMD12 to stop memory multiple block transfer due to some error. If this bit is set to 1, other error status bits (D04 - D01) are meaningless. This bit is set to 0 when Auto CMD Error is generated by Auto CMD23\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Cmd12notexec {
    #[doc = "0: Executed"]
    Executed = 0,
    #[doc = "1: Not Executed"]
    Notexecuted = 1,
}
impl From<Cmd12notexec> for bool {
    #[inline(always)]
    fn from(variant: Cmd12notexec) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `CMD12NOTEXEC` reader - If memory multiple block data transfer is not started due to command error, this bit is not set because it is not necessary to issue Auto CMD12. Setting this bit to 1 means the HC cannot issue Auto CMD12 to stop memory multiple block transfer due to some error. If this bit is set to 1, other error status bits (D04 - D01) are meaningless. This bit is set to 0 when Auto CMD Error is generated by Auto CMD23"]
pub type Cmd12notexecR = crate::BitReader<Cmd12notexec>;
impl Cmd12notexecR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Cmd12notexec {
        match self.bits {
            false => Cmd12notexec::Executed,
            true => Cmd12notexec::Notexecuted,
        }
    }
    #[doc = "Executed"]
    #[inline(always)]
    pub fn is_executed(&self) -> bool {
        *self == Cmd12notexec::Executed
    }
    #[doc = "Not Executed"]
    #[inline(always)]
    pub fn is_notexecuted(&self) -> bool {
        *self == Cmd12notexec::Notexecuted
    }
}
#[doc = "Field `CMD12NOTEXEC` writer - If memory multiple block data transfer is not started due to command error, this bit is not set because it is not necessary to issue Auto CMD12. Setting this bit to 1 means the HC cannot issue Auto CMD12 to stop memory multiple block transfer due to some error. If this bit is set to 1, other error status bits (D04 - D01) are meaningless. This bit is set to 0 when Auto CMD Error is generated by Auto CMD23"]
pub type Cmd12notexecW<'a, REG> = crate::BitWriter<'a, REG, Cmd12notexec>;
impl<'a, REG> Cmd12notexecW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Executed"]
    #[inline(always)]
    pub fn executed(self) -> &'a mut crate::W<REG> {
        self.variant(Cmd12notexec::Executed)
    }
    #[doc = "Not Executed"]
    #[inline(always)]
    pub fn notexecuted(self) -> &'a mut crate::W<REG> {
        self.variant(Cmd12notexec::Notexecuted)
    }
}
#[doc = "Occurs if the no response is returned within 64 SDCLK cycles from the end bit of the command. If this bit is set to 1, the other error status bits (D04 - D02) are meaningless.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Cmdtoerr {
    #[doc = "0: No Error"]
    Noerror = 0,
    #[doc = "1: Timeout"]
    Error = 1,
}
impl From<Cmdtoerr> for bool {
    #[inline(always)]
    fn from(variant: Cmdtoerr) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `CMDTOERR` reader - Occurs if the no response is returned within 64 SDCLK cycles from the end bit of the command. If this bit is set to 1, the other error status bits (D04 - D02) are meaningless."]
pub type CmdtoerrR = crate::BitReader<Cmdtoerr>;
impl CmdtoerrR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Cmdtoerr {
        match self.bits {
            false => Cmdtoerr::Noerror,
            true => Cmdtoerr::Error,
        }
    }
    #[doc = "No Error"]
    #[inline(always)]
    pub fn is_noerror(&self) -> bool {
        *self == Cmdtoerr::Noerror
    }
    #[doc = "Timeout"]
    #[inline(always)]
    pub fn is_error(&self) -> bool {
        *self == Cmdtoerr::Error
    }
}
#[doc = "Field `CMDTOERR` writer - Occurs if the no response is returned within 64 SDCLK cycles from the end bit of the command. If this bit is set to 1, the other error status bits (D04 - D02) are meaningless."]
pub type CmdtoerrW<'a, REG> = crate::BitWriter<'a, REG, Cmdtoerr>;
impl<'a, REG> CmdtoerrW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "No Error"]
    #[inline(always)]
    pub fn noerror(self) -> &'a mut crate::W<REG> {
        self.variant(Cmdtoerr::Noerror)
    }
    #[doc = "Timeout"]
    #[inline(always)]
    pub fn error(self) -> &'a mut crate::W<REG> {
        self.variant(Cmdtoerr::Error)
    }
}
#[doc = "Occurs when detecting a CRC error in the command response.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Cmdcrcerr {
    #[doc = "0: No Error"]
    Noerror = 0,
    #[doc = "1: CRC Error Generated"]
    Error = 1,
}
impl From<Cmdcrcerr> for bool {
    #[inline(always)]
    fn from(variant: Cmdcrcerr) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `CMDCRCERR` reader - Occurs when detecting a CRC error in the command response."]
pub type CmdcrcerrR = crate::BitReader<Cmdcrcerr>;
impl CmdcrcerrR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Cmdcrcerr {
        match self.bits {
            false => Cmdcrcerr::Noerror,
            true => Cmdcrcerr::Error,
        }
    }
    #[doc = "No Error"]
    #[inline(always)]
    pub fn is_noerror(&self) -> bool {
        *self == Cmdcrcerr::Noerror
    }
    #[doc = "CRC Error Generated"]
    #[inline(always)]
    pub fn is_error(&self) -> bool {
        *self == Cmdcrcerr::Error
    }
}
#[doc = "Field `CMDCRCERR` writer - Occurs when detecting a CRC error in the command response."]
pub type CmdcrcerrW<'a, REG> = crate::BitWriter<'a, REG, Cmdcrcerr>;
impl<'a, REG> CmdcrcerrW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "No Error"]
    #[inline(always)]
    pub fn noerror(self) -> &'a mut crate::W<REG> {
        self.variant(Cmdcrcerr::Noerror)
    }
    #[doc = "CRC Error Generated"]
    #[inline(always)]
    pub fn error(self) -> &'a mut crate::W<REG> {
        self.variant(Cmdcrcerr::Error)
    }
}
#[doc = "Occurs when detecting that the end bit of command response is 0.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Cmdenderr {
    #[doc = "0: No Error"]
    Noerror = 0,
    #[doc = "1: End Bit Error Generated"]
    Error = 1,
}
impl From<Cmdenderr> for bool {
    #[inline(always)]
    fn from(variant: Cmdenderr) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `CMDENDERR` reader - Occurs when detecting that the end bit of command response is 0."]
pub type CmdenderrR = crate::BitReader<Cmdenderr>;
impl CmdenderrR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Cmdenderr {
        match self.bits {
            false => Cmdenderr::Noerror,
            true => Cmdenderr::Error,
        }
    }
    #[doc = "No Error"]
    #[inline(always)]
    pub fn is_noerror(&self) -> bool {
        *self == Cmdenderr::Noerror
    }
    #[doc = "End Bit Error Generated"]
    #[inline(always)]
    pub fn is_error(&self) -> bool {
        *self == Cmdenderr::Error
    }
}
#[doc = "Field `CMDENDERR` writer - Occurs when detecting that the end bit of command response is 0."]
pub type CmdenderrW<'a, REG> = crate::BitWriter<'a, REG, Cmdenderr>;
impl<'a, REG> CmdenderrW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "No Error"]
    #[inline(always)]
    pub fn noerror(self) -> &'a mut crate::W<REG> {
        self.variant(Cmdenderr::Noerror)
    }
    #[doc = "End Bit Error Generated"]
    #[inline(always)]
    pub fn error(self) -> &'a mut crate::W<REG> {
        self.variant(Cmdenderr::Error)
    }
}
#[doc = "Occurs if the Command Index error occurs in response to a command.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Cmdidxerr {
    #[doc = "0: No Error"]
    Noerror = 0,
    #[doc = "1: Error"]
    Error = 1,
}
impl From<Cmdidxerr> for bool {
    #[inline(always)]
    fn from(variant: Cmdidxerr) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `CMDIDXERR` reader - Occurs if the Command Index error occurs in response to a command."]
pub type CmdidxerrR = crate::BitReader<Cmdidxerr>;
impl CmdidxerrR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Cmdidxerr {
        match self.bits {
            false => Cmdidxerr::Noerror,
            true => Cmdidxerr::Error,
        }
    }
    #[doc = "No Error"]
    #[inline(always)]
    pub fn is_noerror(&self) -> bool {
        *self == Cmdidxerr::Noerror
    }
    #[doc = "Error"]
    #[inline(always)]
    pub fn is_error(&self) -> bool {
        *self == Cmdidxerr::Error
    }
}
#[doc = "Field `CMDIDXERR` writer - Occurs if the Command Index error occurs in response to a command."]
pub type CmdidxerrW<'a, REG> = crate::BitWriter<'a, REG, Cmdidxerr>;
impl<'a, REG> CmdidxerrW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "No Error"]
    #[inline(always)]
    pub fn noerror(self) -> &'a mut crate::W<REG> {
        self.variant(Cmdidxerr::Noerror)
    }
    #[doc = "Error"]
    #[inline(always)]
    pub fn error(self) -> &'a mut crate::W<REG> {
        self.variant(Cmdidxerr::Error)
    }
}
#[doc = "Setting this bit to 1 means CMD_wo_DAT is not executed due to an Auto CMD12 error (D04 - D01) in this register. This bit is set to 0 when Auto CMD Error is generated by Auto CMD23\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Notautocmd12err {
    #[doc = "0: No Error"]
    Noerror = 0,
    #[doc = "1: Not Issued"]
    Error = 1,
}
impl From<Notautocmd12err> for bool {
    #[inline(always)]
    fn from(variant: Notautocmd12err) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `NOTAUTOCMD12ERR` reader - Setting this bit to 1 means CMD_wo_DAT is not executed due to an Auto CMD12 error (D04 - D01) in this register. This bit is set to 0 when Auto CMD Error is generated by Auto CMD23"]
pub type Notautocmd12errR = crate::BitReader<Notautocmd12err>;
impl Notautocmd12errR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Notautocmd12err {
        match self.bits {
            false => Notautocmd12err::Noerror,
            true => Notautocmd12err::Error,
        }
    }
    #[doc = "No Error"]
    #[inline(always)]
    pub fn is_noerror(&self) -> bool {
        *self == Notautocmd12err::Noerror
    }
    #[doc = "Not Issued"]
    #[inline(always)]
    pub fn is_error(&self) -> bool {
        *self == Notautocmd12err::Error
    }
}
#[doc = "Field `NOTAUTOCMD12ERR` writer - Setting this bit to 1 means CMD_wo_DAT is not executed due to an Auto CMD12 error (D04 - D01) in this register. This bit is set to 0 when Auto CMD Error is generated by Auto CMD23"]
pub type Notautocmd12errW<'a, REG> = crate::BitWriter<'a, REG, Notautocmd12err>;
impl<'a, REG> Notautocmd12errW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "No Error"]
    #[inline(always)]
    pub fn noerror(self) -> &'a mut crate::W<REG> {
        self.variant(Notautocmd12err::Noerror)
    }
    #[doc = "Not Issued"]
    #[inline(always)]
    pub fn error(self) -> &'a mut crate::W<REG> {
        self.variant(Notautocmd12err::Error)
    }
}
#[doc = "This field is used to select one of UHS-I modes and effective when 1.8V Signaling Enable is set to 1. If Preset Value Enable in the Host Control 2 register is set to 1, Host Controller sets SDCLK Frequency Select, Clock Generator Select in the Clock Control register and Driver Strength Select according to Preset Value registers. In this case, one of preset value registers is selected by this field. Host Driver needs to reset SD Clock Enable before changing this field to avoid generating clock glitch. After setting this field, Host Driver sets SD Clock Enable again. When SDR50, SDR104 or DDR50 is selected for SDIO card, interrupt detection at the block gap shall not be used. Read Wait timing is changed for these modes. Refer to the SDIO Specification Version 3.00 for more detail.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u8)]
pub enum Uhsmodesel {
    #[doc = "0: UHS-I mode SDR12"]
    Sdr12 = 0,
    #[doc = "1: UHS-I mode SDR25"]
    Sdr25 = 1,
    #[doc = "2: UHS-I mode SDR50"]
    Sdr50 = 2,
    #[doc = "3: UHS-I mode SDR104"]
    Sdr104 = 3,
    #[doc = "4: UHS-I mode DDR50"]
    Ddr50 = 4,
}
impl From<Uhsmodesel> for u8 {
    #[inline(always)]
    fn from(variant: Uhsmodesel) -> Self {
        variant as _
    }
}
impl crate::FieldSpec for Uhsmodesel {
    type Ux = u8;
}
impl crate::IsEnum for Uhsmodesel {}
#[doc = "Field `UHSMODESEL` reader - This field is used to select one of UHS-I modes and effective when 1.8V Signaling Enable is set to 1. If Preset Value Enable in the Host Control 2 register is set to 1, Host Controller sets SDCLK Frequency Select, Clock Generator Select in the Clock Control register and Driver Strength Select according to Preset Value registers. In this case, one of preset value registers is selected by this field. Host Driver needs to reset SD Clock Enable before changing this field to avoid generating clock glitch. After setting this field, Host Driver sets SD Clock Enable again. When SDR50, SDR104 or DDR50 is selected for SDIO card, interrupt detection at the block gap shall not be used. Read Wait timing is changed for these modes. Refer to the SDIO Specification Version 3.00 for more detail."]
pub type UhsmodeselR = crate::FieldReader<Uhsmodesel>;
impl UhsmodeselR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Option<Uhsmodesel> {
        match self.bits {
            0 => Some(Uhsmodesel::Sdr12),
            1 => Some(Uhsmodesel::Sdr25),
            2 => Some(Uhsmodesel::Sdr50),
            3 => Some(Uhsmodesel::Sdr104),
            4 => Some(Uhsmodesel::Ddr50),
            _ => None,
        }
    }
    #[doc = "UHS-I mode SDR12"]
    #[inline(always)]
    pub fn is_sdr12(&self) -> bool {
        *self == Uhsmodesel::Sdr12
    }
    #[doc = "UHS-I mode SDR25"]
    #[inline(always)]
    pub fn is_sdr25(&self) -> bool {
        *self == Uhsmodesel::Sdr25
    }
    #[doc = "UHS-I mode SDR50"]
    #[inline(always)]
    pub fn is_sdr50(&self) -> bool {
        *self == Uhsmodesel::Sdr50
    }
    #[doc = "UHS-I mode SDR104"]
    #[inline(always)]
    pub fn is_sdr104(&self) -> bool {
        *self == Uhsmodesel::Sdr104
    }
    #[doc = "UHS-I mode DDR50"]
    #[inline(always)]
    pub fn is_ddr50(&self) -> bool {
        *self == Uhsmodesel::Ddr50
    }
}
#[doc = "Field `UHSMODESEL` writer - This field is used to select one of UHS-I modes and effective when 1.8V Signaling Enable is set to 1. If Preset Value Enable in the Host Control 2 register is set to 1, Host Controller sets SDCLK Frequency Select, Clock Generator Select in the Clock Control register and Driver Strength Select according to Preset Value registers. In this case, one of preset value registers is selected by this field. Host Driver needs to reset SD Clock Enable before changing this field to avoid generating clock glitch. After setting this field, Host Driver sets SD Clock Enable again. When SDR50, SDR104 or DDR50 is selected for SDIO card, interrupt detection at the block gap shall not be used. Read Wait timing is changed for these modes. Refer to the SDIO Specification Version 3.00 for more detail."]
pub type UhsmodeselW<'a, REG> = crate::FieldWriter<'a, REG, 3, Uhsmodesel>;
impl<'a, REG> UhsmodeselW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
    REG::Ux: From<u8>,
{
    #[doc = "UHS-I mode SDR12"]
    #[inline(always)]
    pub fn sdr12(self) -> &'a mut crate::W<REG> {
        self.variant(Uhsmodesel::Sdr12)
    }
    #[doc = "UHS-I mode SDR25"]
    #[inline(always)]
    pub fn sdr25(self) -> &'a mut crate::W<REG> {
        self.variant(Uhsmodesel::Sdr25)
    }
    #[doc = "UHS-I mode SDR50"]
    #[inline(always)]
    pub fn sdr50(self) -> &'a mut crate::W<REG> {
        self.variant(Uhsmodesel::Sdr50)
    }
    #[doc = "UHS-I mode SDR104"]
    #[inline(always)]
    pub fn sdr104(self) -> &'a mut crate::W<REG> {
        self.variant(Uhsmodesel::Sdr104)
    }
    #[doc = "UHS-I mode DDR50"]
    #[inline(always)]
    pub fn ddr50(self) -> &'a mut crate::W<REG> {
        self.variant(Uhsmodesel::Ddr50)
    }
}
#[doc = "This bit controls voltage regulator for I/O cell. 3.3V is supplied to the card regardless of signaling voltage. Setting this bit from 0 to 1 starts changing signal voltage from 3.3V to 1.8V. 1.8V regulator output shall be stable within 5ms. Host Controller clears this bit if switching to 1.8V signaling fails. Clearing this bit from 1 to 0 starts changing signal voltage from 1.8V to 3.3V. 3.3V regulator output shall be stable within 5ms. Host Driver can set this bit to 1 when Host Controller supports 1.8V signaling (One of support bits is set to 1: SDR50, SDR104 or DDR50 in the Capabilities register) and the card or device supports UHS-I\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Signalvolt {
    #[doc = "1: 1.8V Signaling"]
    _1_8v = 1,
    #[doc = "0: 3.3V Signaling"]
    _3_3v = 0,
}
impl From<Signalvolt> for bool {
    #[inline(always)]
    fn from(variant: Signalvolt) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `SIGNALVOLT` reader - This bit controls voltage regulator for I/O cell. 3.3V is supplied to the card regardless of signaling voltage. Setting this bit from 0 to 1 starts changing signal voltage from 3.3V to 1.8V. 1.8V regulator output shall be stable within 5ms. Host Controller clears this bit if switching to 1.8V signaling fails. Clearing this bit from 1 to 0 starts changing signal voltage from 1.8V to 3.3V. 3.3V regulator output shall be stable within 5ms. Host Driver can set this bit to 1 when Host Controller supports 1.8V signaling (One of support bits is set to 1: SDR50, SDR104 or DDR50 in the Capabilities register) and the card or device supports UHS-I"]
pub type SignalvoltR = crate::BitReader<Signalvolt>;
impl SignalvoltR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Signalvolt {
        match self.bits {
            true => Signalvolt::_1_8v,
            false => Signalvolt::_3_3v,
        }
    }
    #[doc = "1.8V Signaling"]
    #[inline(always)]
    pub fn is_1_8v(&self) -> bool {
        *self == Signalvolt::_1_8v
    }
    #[doc = "3.3V Signaling"]
    #[inline(always)]
    pub fn is_3_3v(&self) -> bool {
        *self == Signalvolt::_3_3v
    }
}
#[doc = "Field `SIGNALVOLT` writer - This bit controls voltage regulator for I/O cell. 3.3V is supplied to the card regardless of signaling voltage. Setting this bit from 0 to 1 starts changing signal voltage from 3.3V to 1.8V. 1.8V regulator output shall be stable within 5ms. Host Controller clears this bit if switching to 1.8V signaling fails. Clearing this bit from 1 to 0 starts changing signal voltage from 1.8V to 3.3V. 3.3V regulator output shall be stable within 5ms. Host Driver can set this bit to 1 when Host Controller supports 1.8V signaling (One of support bits is set to 1: SDR50, SDR104 or DDR50 in the Capabilities register) and the card or device supports UHS-I"]
pub type SignalvoltW<'a, REG> = crate::BitWriter<'a, REG, Signalvolt>;
impl<'a, REG> SignalvoltW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "1.8V Signaling"]
    #[inline(always)]
    pub fn _1_8v(self) -> &'a mut crate::W<REG> {
        self.variant(Signalvolt::_1_8v)
    }
    #[doc = "3.3V Signaling"]
    #[inline(always)]
    pub fn _3_3v(self) -> &'a mut crate::W<REG> {
        self.variant(Signalvolt::_3_3v)
    }
}
#[doc = "Host Controller output driver in 1.8V signaling is selected by this bit. In 3.3V signaling, this field is not effective. This field can be set depends on Driver Type A, C and D support bits in the Capabilities register. This bit depends on setting of Preset Value Enable. If Preset Value Enable = 0, this field is set by Host Driver. If Preset Value Enable = 1, this field is automatically set by a value specified in the one of Preset Value registers.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u8)]
pub enum Drvrstrsel {
    #[doc = "0: Driver Type B is Selected (Default)"]
    Drvrb = 0,
    #[doc = "1: Driver Type A is Selected"]
    Drvra = 1,
    #[doc = "2: Driver Type C is Selected"]
    Drvrc = 2,
    #[doc = "3: Driver Type D is Selected"]
    Drvrd = 3,
}
impl From<Drvrstrsel> for u8 {
    #[inline(always)]
    fn from(variant: Drvrstrsel) -> Self {
        variant as _
    }
}
impl crate::FieldSpec for Drvrstrsel {
    type Ux = u8;
}
impl crate::IsEnum for Drvrstrsel {}
#[doc = "Field `DRVRSTRSEL` reader - Host Controller output driver in 1.8V signaling is selected by this bit. In 3.3V signaling, this field is not effective. This field can be set depends on Driver Type A, C and D support bits in the Capabilities register. This bit depends on setting of Preset Value Enable. If Preset Value Enable = 0, this field is set by Host Driver. If Preset Value Enable = 1, this field is automatically set by a value specified in the one of Preset Value registers."]
pub type DrvrstrselR = crate::FieldReader<Drvrstrsel>;
impl DrvrstrselR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Drvrstrsel {
        match self.bits {
            0 => Drvrstrsel::Drvrb,
            1 => Drvrstrsel::Drvra,
            2 => Drvrstrsel::Drvrc,
            3 => Drvrstrsel::Drvrd,
            _ => unreachable!(),
        }
    }
    #[doc = "Driver Type B is Selected (Default)"]
    #[inline(always)]
    pub fn is_drvrb(&self) -> bool {
        *self == Drvrstrsel::Drvrb
    }
    #[doc = "Driver Type A is Selected"]
    #[inline(always)]
    pub fn is_drvra(&self) -> bool {
        *self == Drvrstrsel::Drvra
    }
    #[doc = "Driver Type C is Selected"]
    #[inline(always)]
    pub fn is_drvrc(&self) -> bool {
        *self == Drvrstrsel::Drvrc
    }
    #[doc = "Driver Type D is Selected"]
    #[inline(always)]
    pub fn is_drvrd(&self) -> bool {
        *self == Drvrstrsel::Drvrd
    }
}
#[doc = "Field `DRVRSTRSEL` writer - Host Controller output driver in 1.8V signaling is selected by this bit. In 3.3V signaling, this field is not effective. This field can be set depends on Driver Type A, C and D support bits in the Capabilities register. This bit depends on setting of Preset Value Enable. If Preset Value Enable = 0, this field is set by Host Driver. If Preset Value Enable = 1, this field is automatically set by a value specified in the one of Preset Value registers."]
pub type DrvrstrselW<'a, REG> = crate::FieldWriter<'a, REG, 2, Drvrstrsel, crate::Safe>;
impl<'a, REG> DrvrstrselW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
    REG::Ux: From<u8>,
{
    #[doc = "Driver Type B is Selected (Default)"]
    #[inline(always)]
    pub fn drvrb(self) -> &'a mut crate::W<REG> {
        self.variant(Drvrstrsel::Drvrb)
    }
    #[doc = "Driver Type A is Selected"]
    #[inline(always)]
    pub fn drvra(self) -> &'a mut crate::W<REG> {
        self.variant(Drvrstrsel::Drvra)
    }
    #[doc = "Driver Type C is Selected"]
    #[inline(always)]
    pub fn drvrc(self) -> &'a mut crate::W<REG> {
        self.variant(Drvrstrsel::Drvrc)
    }
    #[doc = "Driver Type D is Selected"]
    #[inline(always)]
    pub fn drvrd(self) -> &'a mut crate::W<REG> {
        self.variant(Drvrstrsel::Drvrd)
    }
}
#[doc = "This bit is set to 1 to start tuning procedure and automatically cleared when tuning procedure is completed. The result of tuning is indicated to Sampling Clock Select. Tuning procedure is aborted by writing 0 for more detail about tuning procedure.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Starttuning {
    #[doc = "1: Execute Tuning,"]
    Tunestart = 1,
    #[doc = "0: Not Tuned or Tuning Completed"]
    Tunecmp = 0,
}
impl From<Starttuning> for bool {
    #[inline(always)]
    fn from(variant: Starttuning) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `STARTTUNING` reader - This bit is set to 1 to start tuning procedure and automatically cleared when tuning procedure is completed. The result of tuning is indicated to Sampling Clock Select. Tuning procedure is aborted by writing 0 for more detail about tuning procedure."]
pub type StarttuningR = crate::BitReader<Starttuning>;
impl StarttuningR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Starttuning {
        match self.bits {
            true => Starttuning::Tunestart,
            false => Starttuning::Tunecmp,
        }
    }
    #[doc = "Execute Tuning,"]
    #[inline(always)]
    pub fn is_tunestart(&self) -> bool {
        *self == Starttuning::Tunestart
    }
    #[doc = "Not Tuned or Tuning Completed"]
    #[inline(always)]
    pub fn is_tunecmp(&self) -> bool {
        *self == Starttuning::Tunecmp
    }
}
#[doc = "Field `STARTTUNING` writer - This bit is set to 1 to start tuning procedure and automatically cleared when tuning procedure is completed. The result of tuning is indicated to Sampling Clock Select. Tuning procedure is aborted by writing 0 for more detail about tuning procedure."]
pub type StarttuningW<'a, REG> = crate::BitWriter<'a, REG, Starttuning>;
impl<'a, REG> StarttuningW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Execute Tuning,"]
    #[inline(always)]
    pub fn tunestart(self) -> &'a mut crate::W<REG> {
        self.variant(Starttuning::Tunestart)
    }
    #[doc = "Not Tuned or Tuning Completed"]
    #[inline(always)]
    pub fn tunecmp(self) -> &'a mut crate::W<REG> {
        self.variant(Starttuning::Tunecmp)
    }
}
#[doc = "This bit is set by tuning procedure when Execute Tuning is cleared. Writing 1 to this bit is meaningless and ignored. Setting 1 means that tuning is completed successfully and setting 0 means that tuning is failed. Host Controller uses this bit to select sampling clock to receive CMD and DAT. This bit is cleared by writing 0. Change of this bit is not allowed while the Host Controller is receiving response or a read data block.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Samplclksel {
    #[doc = "1: Tuned clock is used to sample data"]
    Tunedclk = 1,
    #[doc = "0: Fixed clock is used to sample data"]
    Fixedclk = 0,
}
impl From<Samplclksel> for bool {
    #[inline(always)]
    fn from(variant: Samplclksel) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `SAMPLCLKSEL` reader - This bit is set by tuning procedure when Execute Tuning is cleared. Writing 1 to this bit is meaningless and ignored. Setting 1 means that tuning is completed successfully and setting 0 means that tuning is failed. Host Controller uses this bit to select sampling clock to receive CMD and DAT. This bit is cleared by writing 0. Change of this bit is not allowed while the Host Controller is receiving response or a read data block."]
pub type SamplclkselR = crate::BitReader<Samplclksel>;
impl SamplclkselR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Samplclksel {
        match self.bits {
            true => Samplclksel::Tunedclk,
            false => Samplclksel::Fixedclk,
        }
    }
    #[doc = "Tuned clock is used to sample data"]
    #[inline(always)]
    pub fn is_tunedclk(&self) -> bool {
        *self == Samplclksel::Tunedclk
    }
    #[doc = "Fixed clock is used to sample data"]
    #[inline(always)]
    pub fn is_fixedclk(&self) -> bool {
        *self == Samplclksel::Fixedclk
    }
}
#[doc = "Field `SAMPLCLKSEL` writer - This bit is set by tuning procedure when Execute Tuning is cleared. Writing 1 to this bit is meaningless and ignored. Setting 1 means that tuning is completed successfully and setting 0 means that tuning is failed. Host Controller uses this bit to select sampling clock to receive CMD and DAT. This bit is cleared by writing 0. Change of this bit is not allowed while the Host Controller is receiving response or a read data block."]
pub type SamplclkselW<'a, REG> = crate::BitWriter<'a, REG, Samplclksel>;
impl<'a, REG> SamplclkselW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Tuned clock is used to sample data"]
    #[inline(always)]
    pub fn tunedclk(self) -> &'a mut crate::W<REG> {
        self.variant(Samplclksel::Tunedclk)
    }
    #[doc = "Fixed clock is used to sample data"]
    #[inline(always)]
    pub fn fixedclk(self) -> &'a mut crate::W<REG> {
        self.variant(Samplclksel::Fixedclk)
    }
}
#[doc = "This bit can be set to 1 if a card support asynchronous interrupt and Asynchronous Interrupt Support is set to 1 in the Capabilities register. Asynchronous interrupt is effective when DAT\\[1\\]
interrupt is used in 4-bit SD mode (and zero is set to Interrupt Pin Select in the Shared Bus Control register). If this bit is set to 1, the Host Driver can stop the SDCLK during asynchronous interrupt period to save power. During this period, the Host Controller continues to deliver Card Interrupt to the host when it is asserted by the Card.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Asyncinten {
    #[doc = "1: Enabled,"]
    Enabled = 1,
    #[doc = "0: Disabled"]
    Disabled = 0,
}
impl From<Asyncinten> for bool {
    #[inline(always)]
    fn from(variant: Asyncinten) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `ASYNCINTEN` reader - This bit can be set to 1 if a card support asynchronous interrupt and Asynchronous Interrupt Support is set to 1 in the Capabilities register. Asynchronous interrupt is effective when DAT\\[1\\]
interrupt is used in 4-bit SD mode (and zero is set to Interrupt Pin Select in the Shared Bus Control register). If this bit is set to 1, the Host Driver can stop the SDCLK during asynchronous interrupt period to save power. During this period, the Host Controller continues to deliver Card Interrupt to the host when it is asserted by the Card."]
pub type AsyncintenR = crate::BitReader<Asyncinten>;
impl AsyncintenR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Asyncinten {
        match self.bits {
            true => Asyncinten::Enabled,
            false => Asyncinten::Disabled,
        }
    }
    #[doc = "Enabled,"]
    #[inline(always)]
    pub fn is_enabled(&self) -> bool {
        *self == Asyncinten::Enabled
    }
    #[doc = "Disabled"]
    #[inline(always)]
    pub fn is_disabled(&self) -> bool {
        *self == Asyncinten::Disabled
    }
}
#[doc = "Field `ASYNCINTEN` writer - This bit can be set to 1 if a card support asynchronous interrupt and Asynchronous Interrupt Support is set to 1 in the Capabilities register. Asynchronous interrupt is effective when DAT\\[1\\]
interrupt is used in 4-bit SD mode (and zero is set to Interrupt Pin Select in the Shared Bus Control register). If this bit is set to 1, the Host Driver can stop the SDCLK during asynchronous interrupt period to save power. During this period, the Host Controller continues to deliver Card Interrupt to the host when it is asserted by the Card."]
pub type AsyncintenW<'a, REG> = crate::BitWriter<'a, REG, Asyncinten>;
impl<'a, REG> AsyncintenW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Enabled,"]
    #[inline(always)]
    pub fn enabled(self) -> &'a mut crate::W<REG> {
        self.variant(Asyncinten::Enabled)
    }
    #[doc = "Disabled"]
    #[inline(always)]
    pub fn disabled(self) -> &'a mut crate::W<REG> {
        self.variant(Asyncinten::Disabled)
    }
}
#[doc = "Host Controller Version 3.00 supports this bit. As the operating SDCLK frequency and I/O driver strength depend on the Host System implementation, it is difficult to determine these parameters in the Standard Host Driver. When Preset Value Enable is set to automatic. This bit enables the functions defined in the Preset Value registers. If this bit is set to 0, SDCLK Frequency Select, Clock Generator Select in the Clock Control register and Driver Strength Select in Host Control 2 register are set by Host Driver. If this bit is set to 1, SDCLK Frequency Select, Clock Generator Select in the Clock Control register and Driver Strength Select in Host Control 2 register are set by Host Controller as specified in the Preset Value registers.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Preseten {
    #[doc = "1: Automatic Selection by Preset Value are Enabled"]
    Autoen = 1,
    #[doc = "0: SDCLK and Driver Strength are controlled by Host Driver"]
    Hostctrl = 0,
}
impl From<Preseten> for bool {
    #[inline(always)]
    fn from(variant: Preseten) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `PRESETEN` reader - Host Controller Version 3.00 supports this bit. As the operating SDCLK frequency and I/O driver strength depend on the Host System implementation, it is difficult to determine these parameters in the Standard Host Driver. When Preset Value Enable is set to automatic. This bit enables the functions defined in the Preset Value registers. If this bit is set to 0, SDCLK Frequency Select, Clock Generator Select in the Clock Control register and Driver Strength Select in Host Control 2 register are set by Host Driver. If this bit is set to 1, SDCLK Frequency Select, Clock Generator Select in the Clock Control register and Driver Strength Select in Host Control 2 register are set by Host Controller as specified in the Preset Value registers."]
pub type PresetenR = crate::BitReader<Preseten>;
impl PresetenR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Preseten {
        match self.bits {
            true => Preseten::Autoen,
            false => Preseten::Hostctrl,
        }
    }
    #[doc = "Automatic Selection by Preset Value are Enabled"]
    #[inline(always)]
    pub fn is_autoen(&self) -> bool {
        *self == Preseten::Autoen
    }
    #[doc = "SDCLK and Driver Strength are controlled by Host Driver"]
    #[inline(always)]
    pub fn is_hostctrl(&self) -> bool {
        *self == Preseten::Hostctrl
    }
}
#[doc = "Field `PRESETEN` writer - Host Controller Version 3.00 supports this bit. As the operating SDCLK frequency and I/O driver strength depend on the Host System implementation, it is difficult to determine these parameters in the Standard Host Driver. When Preset Value Enable is set to automatic. This bit enables the functions defined in the Preset Value registers. If this bit is set to 0, SDCLK Frequency Select, Clock Generator Select in the Clock Control register and Driver Strength Select in Host Control 2 register are set by Host Driver. If this bit is set to 1, SDCLK Frequency Select, Clock Generator Select in the Clock Control register and Driver Strength Select in Host Control 2 register are set by Host Controller as specified in the Preset Value registers."]
pub type PresetenW<'a, REG> = crate::BitWriter<'a, REG, Preseten>;
impl<'a, REG> PresetenW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Automatic Selection by Preset Value are Enabled"]
    #[inline(always)]
    pub fn autoen(self) -> &'a mut crate::W<REG> {
        self.variant(Preseten::Autoen)
    }
    #[doc = "SDCLK and Driver Strength are controlled by Host Driver"]
    #[inline(always)]
    pub fn hostctrl(self) -> &'a mut crate::W<REG> {
        self.variant(Preseten::Hostctrl)
    }
}
impl R {
    #[doc = "Bit 0 - If memory multiple block data transfer is not started due to command error, this bit is not set because it is not necessary to issue Auto CMD12. Setting this bit to 1 means the HC cannot issue Auto CMD12 to stop memory multiple block transfer due to some error. If this bit is set to 1, other error status bits (D04 - D01) are meaningless. This bit is set to 0 when Auto CMD Error is generated by Auto CMD23"]
    #[inline(always)]
    pub fn cmd12notexec(&self) -> Cmd12notexecR {
        Cmd12notexecR::new((self.bits & 1) != 0)
    }
    #[doc = "Bit 1 - Occurs if the no response is returned within 64 SDCLK cycles from the end bit of the command. If this bit is set to 1, the other error status bits (D04 - D02) are meaningless."]
    #[inline(always)]
    pub fn cmdtoerr(&self) -> CmdtoerrR {
        CmdtoerrR::new(((self.bits >> 1) & 1) != 0)
    }
    #[doc = "Bit 2 - Occurs when detecting a CRC error in the command response."]
    #[inline(always)]
    pub fn cmdcrcerr(&self) -> CmdcrcerrR {
        CmdcrcerrR::new(((self.bits >> 2) & 1) != 0)
    }
    #[doc = "Bit 3 - Occurs when detecting that the end bit of command response is 0."]
    #[inline(always)]
    pub fn cmdenderr(&self) -> CmdenderrR {
        CmdenderrR::new(((self.bits >> 3) & 1) != 0)
    }
    #[doc = "Bit 4 - Occurs if the Command Index error occurs in response to a command."]
    #[inline(always)]
    pub fn cmdidxerr(&self) -> CmdidxerrR {
        CmdidxerrR::new(((self.bits >> 4) & 1) != 0)
    }
    #[doc = "Bit 7 - Setting this bit to 1 means CMD_wo_DAT is not executed due to an Auto CMD12 error (D04 - D01) in this register. This bit is set to 0 when Auto CMD Error is generated by Auto CMD23"]
    #[inline(always)]
    pub fn notautocmd12err(&self) -> Notautocmd12errR {
        Notautocmd12errR::new(((self.bits >> 7) & 1) != 0)
    }
    #[doc = "Bits 16:18 - This field is used to select one of UHS-I modes and effective when 1.8V Signaling Enable is set to 1. If Preset Value Enable in the Host Control 2 register is set to 1, Host Controller sets SDCLK Frequency Select, Clock Generator Select in the Clock Control register and Driver Strength Select according to Preset Value registers. In this case, one of preset value registers is selected by this field. Host Driver needs to reset SD Clock Enable before changing this field to avoid generating clock glitch. After setting this field, Host Driver sets SD Clock Enable again. When SDR50, SDR104 or DDR50 is selected for SDIO card, interrupt detection at the block gap shall not be used. Read Wait timing is changed for these modes. Refer to the SDIO Specification Version 3.00 for more detail."]
    #[inline(always)]
    pub fn uhsmodesel(&self) -> UhsmodeselR {
        UhsmodeselR::new(((self.bits >> 16) & 7) as u8)
    }
    #[doc = "Bit 19 - This bit controls voltage regulator for I/O cell. 3.3V is supplied to the card regardless of signaling voltage. Setting this bit from 0 to 1 starts changing signal voltage from 3.3V to 1.8V. 1.8V regulator output shall be stable within 5ms. Host Controller clears this bit if switching to 1.8V signaling fails. Clearing this bit from 1 to 0 starts changing signal voltage from 1.8V to 3.3V. 3.3V regulator output shall be stable within 5ms. Host Driver can set this bit to 1 when Host Controller supports 1.8V signaling (One of support bits is set to 1: SDR50, SDR104 or DDR50 in the Capabilities register) and the card or device supports UHS-I"]
    #[inline(always)]
    pub fn signalvolt(&self) -> SignalvoltR {
        SignalvoltR::new(((self.bits >> 19) & 1) != 0)
    }
    #[doc = "Bits 20:21 - Host Controller output driver in 1.8V signaling is selected by this bit. In 3.3V signaling, this field is not effective. This field can be set depends on Driver Type A, C and D support bits in the Capabilities register. This bit depends on setting of Preset Value Enable. If Preset Value Enable = 0, this field is set by Host Driver. If Preset Value Enable = 1, this field is automatically set by a value specified in the one of Preset Value registers."]
    #[inline(always)]
    pub fn drvrstrsel(&self) -> DrvrstrselR {
        DrvrstrselR::new(((self.bits >> 20) & 3) as u8)
    }
    #[doc = "Bit 22 - This bit is set to 1 to start tuning procedure and automatically cleared when tuning procedure is completed. The result of tuning is indicated to Sampling Clock Select. Tuning procedure is aborted by writing 0 for more detail about tuning procedure."]
    #[inline(always)]
    pub fn starttuning(&self) -> StarttuningR {
        StarttuningR::new(((self.bits >> 22) & 1) != 0)
    }
    #[doc = "Bit 23 - This bit is set by tuning procedure when Execute Tuning is cleared. Writing 1 to this bit is meaningless and ignored. Setting 1 means that tuning is completed successfully and setting 0 means that tuning is failed. Host Controller uses this bit to select sampling clock to receive CMD and DAT. This bit is cleared by writing 0. Change of this bit is not allowed while the Host Controller is receiving response or a read data block."]
    #[inline(always)]
    pub fn samplclksel(&self) -> SamplclkselR {
        SamplclkselR::new(((self.bits >> 23) & 1) != 0)
    }
    #[doc = "Bit 30 - This bit can be set to 1 if a card support asynchronous interrupt and Asynchronous Interrupt Support is set to 1 in the Capabilities register. Asynchronous interrupt is effective when DAT\\[1\\]
interrupt is used in 4-bit SD mode (and zero is set to Interrupt Pin Select in the Shared Bus Control register). If this bit is set to 1, the Host Driver can stop the SDCLK during asynchronous interrupt period to save power. During this period, the Host Controller continues to deliver Card Interrupt to the host when it is asserted by the Card."]
    #[inline(always)]
    pub fn asyncinten(&self) -> AsyncintenR {
        AsyncintenR::new(((self.bits >> 30) & 1) != 0)
    }
    #[doc = "Bit 31 - Host Controller Version 3.00 supports this bit. As the operating SDCLK frequency and I/O driver strength depend on the Host System implementation, it is difficult to determine these parameters in the Standard Host Driver. When Preset Value Enable is set to automatic. This bit enables the functions defined in the Preset Value registers. If this bit is set to 0, SDCLK Frequency Select, Clock Generator Select in the Clock Control register and Driver Strength Select in Host Control 2 register are set by Host Driver. If this bit is set to 1, SDCLK Frequency Select, Clock Generator Select in the Clock Control register and Driver Strength Select in Host Control 2 register are set by Host Controller as specified in the Preset Value registers."]
    #[inline(always)]
    pub fn preseten(&self) -> PresetenR {
        PresetenR::new(((self.bits >> 31) & 1) != 0)
    }
}
impl W {
    #[doc = "Bit 0 - If memory multiple block data transfer is not started due to command error, this bit is not set because it is not necessary to issue Auto CMD12. Setting this bit to 1 means the HC cannot issue Auto CMD12 to stop memory multiple block transfer due to some error. If this bit is set to 1, other error status bits (D04 - D01) are meaningless. This bit is set to 0 when Auto CMD Error is generated by Auto CMD23"]
    #[inline(always)]
    #[must_use]
    pub fn cmd12notexec(&mut self) -> Cmd12notexecW<AutoSpec> {
        Cmd12notexecW::new(self, 0)
    }
    #[doc = "Bit 1 - Occurs if the no response is returned within 64 SDCLK cycles from the end bit of the command. If this bit is set to 1, the other error status bits (D04 - D02) are meaningless."]
    #[inline(always)]
    #[must_use]
    pub fn cmdtoerr(&mut self) -> CmdtoerrW<AutoSpec> {
        CmdtoerrW::new(self, 1)
    }
    #[doc = "Bit 2 - Occurs when detecting a CRC error in the command response."]
    #[inline(always)]
    #[must_use]
    pub fn cmdcrcerr(&mut self) -> CmdcrcerrW<AutoSpec> {
        CmdcrcerrW::new(self, 2)
    }
    #[doc = "Bit 3 - Occurs when detecting that the end bit of command response is 0."]
    #[inline(always)]
    #[must_use]
    pub fn cmdenderr(&mut self) -> CmdenderrW<AutoSpec> {
        CmdenderrW::new(self, 3)
    }
    #[doc = "Bit 4 - Occurs if the Command Index error occurs in response to a command."]
    #[inline(always)]
    #[must_use]
    pub fn cmdidxerr(&mut self) -> CmdidxerrW<AutoSpec> {
        CmdidxerrW::new(self, 4)
    }
    #[doc = "Bit 7 - Setting this bit to 1 means CMD_wo_DAT is not executed due to an Auto CMD12 error (D04 - D01) in this register. This bit is set to 0 when Auto CMD Error is generated by Auto CMD23"]
    #[inline(always)]
    #[must_use]
    pub fn notautocmd12err(&mut self) -> Notautocmd12errW<AutoSpec> {
        Notautocmd12errW::new(self, 7)
    }
    #[doc = "Bits 16:18 - This field is used to select one of UHS-I modes and effective when 1.8V Signaling Enable is set to 1. If Preset Value Enable in the Host Control 2 register is set to 1, Host Controller sets SDCLK Frequency Select, Clock Generator Select in the Clock Control register and Driver Strength Select according to Preset Value registers. In this case, one of preset value registers is selected by this field. Host Driver needs to reset SD Clock Enable before changing this field to avoid generating clock glitch. After setting this field, Host Driver sets SD Clock Enable again. When SDR50, SDR104 or DDR50 is selected for SDIO card, interrupt detection at the block gap shall not be used. Read Wait timing is changed for these modes. Refer to the SDIO Specification Version 3.00 for more detail."]
    #[inline(always)]
    #[must_use]
    pub fn uhsmodesel(&mut self) -> UhsmodeselW<AutoSpec> {
        UhsmodeselW::new(self, 16)
    }
    #[doc = "Bit 19 - This bit controls voltage regulator for I/O cell. 3.3V is supplied to the card regardless of signaling voltage. Setting this bit from 0 to 1 starts changing signal voltage from 3.3V to 1.8V. 1.8V regulator output shall be stable within 5ms. Host Controller clears this bit if switching to 1.8V signaling fails. Clearing this bit from 1 to 0 starts changing signal voltage from 1.8V to 3.3V. 3.3V regulator output shall be stable within 5ms. Host Driver can set this bit to 1 when Host Controller supports 1.8V signaling (One of support bits is set to 1: SDR50, SDR104 or DDR50 in the Capabilities register) and the card or device supports UHS-I"]
    #[inline(always)]
    #[must_use]
    pub fn signalvolt(&mut self) -> SignalvoltW<AutoSpec> {
        SignalvoltW::new(self, 19)
    }
    #[doc = "Bits 20:21 - Host Controller output driver in 1.8V signaling is selected by this bit. In 3.3V signaling, this field is not effective. This field can be set depends on Driver Type A, C and D support bits in the Capabilities register. This bit depends on setting of Preset Value Enable. If Preset Value Enable = 0, this field is set by Host Driver. If Preset Value Enable = 1, this field is automatically set by a value specified in the one of Preset Value registers."]
    #[inline(always)]
    #[must_use]
    pub fn drvrstrsel(&mut self) -> DrvrstrselW<AutoSpec> {
        DrvrstrselW::new(self, 20)
    }
    #[doc = "Bit 22 - This bit is set to 1 to start tuning procedure and automatically cleared when tuning procedure is completed. The result of tuning is indicated to Sampling Clock Select. Tuning procedure is aborted by writing 0 for more detail about tuning procedure."]
    #[inline(always)]
    #[must_use]
    pub fn starttuning(&mut self) -> StarttuningW<AutoSpec> {
        StarttuningW::new(self, 22)
    }
    #[doc = "Bit 23 - This bit is set by tuning procedure when Execute Tuning is cleared. Writing 1 to this bit is meaningless and ignored. Setting 1 means that tuning is completed successfully and setting 0 means that tuning is failed. Host Controller uses this bit to select sampling clock to receive CMD and DAT. This bit is cleared by writing 0. Change of this bit is not allowed while the Host Controller is receiving response or a read data block."]
    #[inline(always)]
    #[must_use]
    pub fn samplclksel(&mut self) -> SamplclkselW<AutoSpec> {
        SamplclkselW::new(self, 23)
    }
    #[doc = "Bit 30 - This bit can be set to 1 if a card support asynchronous interrupt and Asynchronous Interrupt Support is set to 1 in the Capabilities register. Asynchronous interrupt is effective when DAT\\[1\\]
interrupt is used in 4-bit SD mode (and zero is set to Interrupt Pin Select in the Shared Bus Control register). If this bit is set to 1, the Host Driver can stop the SDCLK during asynchronous interrupt period to save power. During this period, the Host Controller continues to deliver Card Interrupt to the host when it is asserted by the Card."]
    #[inline(always)]
    #[must_use]
    pub fn asyncinten(&mut self) -> AsyncintenW<AutoSpec> {
        AsyncintenW::new(self, 30)
    }
    #[doc = "Bit 31 - Host Controller Version 3.00 supports this bit. As the operating SDCLK frequency and I/O driver strength depend on the Host System implementation, it is difficult to determine these parameters in the Standard Host Driver. When Preset Value Enable is set to automatic. This bit enables the functions defined in the Preset Value registers. If this bit is set to 0, SDCLK Frequency Select, Clock Generator Select in the Clock Control register and Driver Strength Select in Host Control 2 register are set by Host Driver. If this bit is set to 1, SDCLK Frequency Select, Clock Generator Select in the Clock Control register and Driver Strength Select in Host Control 2 register are set by Host Controller as specified in the Preset Value registers."]
    #[inline(always)]
    #[must_use]
    pub fn preseten(&mut self) -> PresetenW<AutoSpec> {
        PresetenW::new(self, 31)
    }
}
#[doc = "Auto CMD error status\n\nYou can [`read`](crate::Reg::read) this register and get [`auto::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`auto::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct AutoSpec;
impl crate::RegisterSpec for AutoSpec {
    type Ux = u32;
}
#[doc = "`read()` method returns [`auto::R`](R) reader structure"]
impl crate::Readable for AutoSpec {}
#[doc = "`write(|w| ..)` method takes [`auto::W`](W) writer structure"]
impl crate::Writable for AutoSpec {
    type Safety = crate::Unsafe;
    const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
    const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
}
#[doc = "`reset()` method sets AUTO to value 0"]
impl crate::Resettable for AutoSpec {
    const RESET_VALUE: u32 = 0;
}
