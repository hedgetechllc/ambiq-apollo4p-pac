#![doc = "Peripheral access API for APOLLO4P microcontrollers (generated using svd2rust v0.33.4 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.33.4/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 3;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {
    fn BROWNOUT();
    fn WDT();
    fn RTC();
    fn VCOMP();
    fn IOSLAVE();
    fn IOSLAVEACC();
    fn IOMSTR0();
    fn IOMSTR1();
    fn IOMSTR2();
    fn IOMSTR3();
    fn IOMSTR4();
    fn IOMSTR5();
    fn IOMSTR6();
    fn IOMSTR7();
    fn TIMER();
    fn UART0();
    fn UART1();
    fn UART2();
    fn UART3();
    fn ADC();
    fn MSPI0();
    fn MSPI1();
    fn MSPI2();
    fn CLKGEN();
    fn CRYPTOSEC();
    fn SDIO();
    fn USB0();
    fn GPU();
    fn DC();
    fn DSI();
    fn STIMER_CMPR0();
    fn STIMER_CMPR1();
    fn STIMER_CMPR2();
    fn STIMER_CMPR3();
    fn STIMER_CMPR4();
    fn STIMER_CMPR5();
    fn STIMER_CMPR6();
    fn STIMER_CMPR7();
    fn STIMER_OVF();
    fn AUDADC0();
    fn I2S0();
    fn I2S1();
    fn PDM0();
    fn PDM1();
    fn PDM2();
    fn PDM3();
    fn GPIO0_001F();
    fn GPIO0_203F();
    fn GPIO0_405F();
    fn GPIO0_607F();
    fn GPIO1_001F();
    fn GPIO1_203F();
    fn GPIO1_405F();
    fn GPIO1_607F();
    fn TIMER0();
    fn TIMER1();
    fn TIMER2();
    fn TIMER3();
    fn TIMER4();
    fn TIMER5();
    fn TIMER6();
    fn TIMER7();
    fn TIMER8();
    fn TIMER9();
    fn TIMER10();
    fn TIMER11();
    fn TIMER12();
    fn TIMER13();
    fn TIMER14();
    fn TIMER15();
    fn CACHE();
    fn MAX();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 85] = [
    Vector { _handler: BROWNOUT },
    Vector { _handler: WDT },
    Vector { _handler: RTC },
    Vector { _handler: VCOMP },
    Vector { _handler: IOSLAVE },
    Vector {
        _handler: IOSLAVEACC,
    },
    Vector { _handler: IOMSTR0 },
    Vector { _handler: IOMSTR1 },
    Vector { _handler: IOMSTR2 },
    Vector { _handler: IOMSTR3 },
    Vector { _handler: IOMSTR4 },
    Vector { _handler: IOMSTR5 },
    Vector { _handler: IOMSTR6 },
    Vector { _handler: IOMSTR7 },
    Vector { _handler: TIMER },
    Vector { _handler: UART0 },
    Vector { _handler: UART1 },
    Vector { _handler: UART2 },
    Vector { _handler: UART3 },
    Vector { _handler: ADC },
    Vector { _handler: MSPI0 },
    Vector { _handler: MSPI1 },
    Vector { _handler: MSPI2 },
    Vector { _handler: CLKGEN },
    Vector {
        _handler: CRYPTOSEC,
    },
    Vector { _reserved: 0 },
    Vector { _handler: SDIO },
    Vector { _handler: USB0 },
    Vector { _handler: GPU },
    Vector { _handler: DC },
    Vector { _handler: DSI },
    Vector { _reserved: 0 },
    Vector {
        _handler: STIMER_CMPR0,
    },
    Vector {
        _handler: STIMER_CMPR1,
    },
    Vector {
        _handler: STIMER_CMPR2,
    },
    Vector {
        _handler: STIMER_CMPR3,
    },
    Vector {
        _handler: STIMER_CMPR4,
    },
    Vector {
        _handler: STIMER_CMPR5,
    },
    Vector {
        _handler: STIMER_CMPR6,
    },
    Vector {
        _handler: STIMER_CMPR7,
    },
    Vector {
        _handler: STIMER_OVF,
    },
    Vector { _reserved: 0 },
    Vector { _handler: AUDADC0 },
    Vector { _reserved: 0 },
    Vector { _handler: I2S0 },
    Vector { _handler: I2S1 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: PDM0 },
    Vector { _handler: PDM1 },
    Vector { _handler: PDM2 },
    Vector { _handler: PDM3 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector {
        _handler: GPIO0_001F,
    },
    Vector {
        _handler: GPIO0_203F,
    },
    Vector {
        _handler: GPIO0_405F,
    },
    Vector {
        _handler: GPIO0_607F,
    },
    Vector {
        _handler: GPIO1_001F,
    },
    Vector {
        _handler: GPIO1_203F,
    },
    Vector {
        _handler: GPIO1_405F,
    },
    Vector {
        _handler: GPIO1_607F,
    },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: TIMER0 },
    Vector { _handler: TIMER1 },
    Vector { _handler: TIMER2 },
    Vector { _handler: TIMER3 },
    Vector { _handler: TIMER4 },
    Vector { _handler: TIMER5 },
    Vector { _handler: TIMER6 },
    Vector { _handler: TIMER7 },
    Vector { _handler: TIMER8 },
    Vector { _handler: TIMER9 },
    Vector { _handler: TIMER10 },
    Vector { _handler: TIMER11 },
    Vector { _handler: TIMER12 },
    Vector { _handler: TIMER13 },
    Vector { _handler: TIMER14 },
    Vector { _handler: TIMER15 },
    Vector { _handler: CACHE },
    Vector { _handler: MAX },
];
#[doc = r"Enumeration of all the interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    #[doc = "0 - BROWNOUT_IRQ"]
    BROWNOUT = 0,
    #[doc = "1 - WDT_IRQ"]
    WDT = 1,
    #[doc = "2 - RTC_IRQ"]
    RTC = 2,
    #[doc = "3 - VCOMP_IRQ"]
    VCOMP = 3,
    #[doc = "4 - IOSLAVE_IRQ"]
    IOSLAVE = 4,
    #[doc = "5 - IOSLAVEACC_IRQ"]
    IOSLAVEACC = 5,
    #[doc = "6 - IOMSTR0_IRQ"]
    IOMSTR0 = 6,
    #[doc = "7 - IOMSTR1_IRQ"]
    IOMSTR1 = 7,
    #[doc = "8 - IOMSTR2_IRQ"]
    IOMSTR2 = 8,
    #[doc = "9 - IOMSTR3_IRQ"]
    IOMSTR3 = 9,
    #[doc = "10 - IOMSTR4_IRQ"]
    IOMSTR4 = 10,
    #[doc = "11 - IOMSTR5_IRQ"]
    IOMSTR5 = 11,
    #[doc = "12 - IOMSTR6_IRQ"]
    IOMSTR6 = 12,
    #[doc = "13 - IOMSTR7_IRQ"]
    IOMSTR7 = 13,
    #[doc = "14 - TIMER_IRQ"]
    TIMER = 14,
    #[doc = "15 - UART0_IRQ"]
    UART0 = 15,
    #[doc = "16 - UART1_IRQ"]
    UART1 = 16,
    #[doc = "17 - UART2_IRQ"]
    UART2 = 17,
    #[doc = "18 - UART3_IRQ"]
    UART3 = 18,
    #[doc = "19 - ADC_IRQ"]
    ADC = 19,
    #[doc = "20 - MSPI0_IRQ"]
    MSPI0 = 20,
    #[doc = "21 - MSPI1_IRQ"]
    MSPI1 = 21,
    #[doc = "22 - MSPI2_IRQ"]
    MSPI2 = 22,
    #[doc = "23 - CLKGEN_IRQ"]
    CLKGEN = 23,
    #[doc = "24 - CRYPTOSEC_IRQ"]
    CRYPTOSEC = 24,
    #[doc = "26 - SDIO_IRQ"]
    SDIO = 26,
    #[doc = "27 - USB0_IRQ"]
    USB0 = 27,
    #[doc = "28 - GPU_IRQ"]
    GPU = 28,
    #[doc = "29 - DC_IRQ"]
    DC = 29,
    #[doc = "30 - DSI_IRQ"]
    DSI = 30,
    #[doc = "32 - STIMER_CMPR0_IRQ"]
    STIMER_CMPR0 = 32,
    #[doc = "33 - STIMER_CMPR1_IRQ"]
    STIMER_CMPR1 = 33,
    #[doc = "34 - STIMER_CMPR2_IRQ"]
    STIMER_CMPR2 = 34,
    #[doc = "35 - STIMER_CMPR3_IRQ"]
    STIMER_CMPR3 = 35,
    #[doc = "36 - STIMER_CMPR4_IRQ"]
    STIMER_CMPR4 = 36,
    #[doc = "37 - STIMER_CMPR5_IRQ"]
    STIMER_CMPR5 = 37,
    #[doc = "38 - STIMER_CMPR6_IRQ"]
    STIMER_CMPR6 = 38,
    #[doc = "39 - STIMER_CMPR7_IRQ"]
    STIMER_CMPR7 = 39,
    #[doc = "40 - STIMER_OVF_IRQ"]
    STIMER_OVF = 40,
    #[doc = "42 - AUDADC0_IRQ"]
    AUDADC0 = 42,
    #[doc = "44 - I2S0_IRQ"]
    I2S0 = 44,
    #[doc = "45 - I2S1_IRQ"]
    I2S1 = 45,
    #[doc = "48 - PDM0_IRQ"]
    PDM0 = 48,
    #[doc = "49 - PDM1_IRQ"]
    PDM1 = 49,
    #[doc = "50 - PDM2_IRQ"]
    PDM2 = 50,
    #[doc = "51 - PDM3_IRQ"]
    PDM3 = 51,
    #[doc = "56 - GPIO0_001F_IRQ"]
    GPIO0_001F = 56,
    #[doc = "57 - GPIO0_203F_IRQ"]
    GPIO0_203F = 57,
    #[doc = "58 - GPIO0_405F_IRQ"]
    GPIO0_405F = 58,
    #[doc = "59 - GPIO0_607F_IRQ"]
    GPIO0_607F = 59,
    #[doc = "60 - GPIO1_001F_IRQ"]
    GPIO1_001F = 60,
    #[doc = "61 - GPIO1_203F_IRQ"]
    GPIO1_203F = 61,
    #[doc = "62 - GPIO1_405F_IRQ"]
    GPIO1_405F = 62,
    #[doc = "63 - GPIO1_607F_IRQ"]
    GPIO1_607F = 63,
    #[doc = "67 - TIMER0_IRQ"]
    TIMER0 = 67,
    #[doc = "68 - TIMER1_IRQ"]
    TIMER1 = 68,
    #[doc = "69 - TIMER2_IRQ"]
    TIMER2 = 69,
    #[doc = "70 - TIMER3_IRQ"]
    TIMER3 = 70,
    #[doc = "71 - TIMER4_IRQ"]
    TIMER4 = 71,
    #[doc = "72 - TIMER5_IRQ"]
    TIMER5 = 72,
    #[doc = "73 - TIMER6_IRQ"]
    TIMER6 = 73,
    #[doc = "74 - TIMER7_IRQ"]
    TIMER7 = 74,
    #[doc = "75 - TIMER8_IRQ"]
    TIMER8 = 75,
    #[doc = "76 - TIMER9_IRQ"]
    TIMER9 = 76,
    #[doc = "77 - TIMER10_IRQ"]
    TIMER10 = 77,
    #[doc = "78 - TIMER11_IRQ"]
    TIMER11 = 78,
    #[doc = "79 - TIMER12_IRQ"]
    TIMER12 = 79,
    #[doc = "80 - TIMER13_IRQ"]
    TIMER13 = 80,
    #[doc = "81 - TIMER14_IRQ"]
    TIMER14 = 81,
    #[doc = "82 - TIMER15_IRQ"]
    TIMER15 = 82,
    #[doc = "83 - CACHE_IRQ"]
    CACHE = 83,
    #[doc = "84 - Not a valid IRQ. The maximum IRQ is this value - 1."]
    MAX = 84,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[doc = "Analog Digital Converter Control"]
pub struct Adc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Adc {}
impl Adc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const adc::RegisterBlock = 0x4003_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const adc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Adc {
    type Target = adc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Adc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Adc").finish()
    }
}
#[doc = "Analog Digital Converter Control"]
pub mod adc;
#[doc = "APB DMA Register Interfaces"]
pub struct Apbdma {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Apbdma {}
impl Apbdma {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const apbdma::RegisterBlock = 0x4001_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const apbdma::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Apbdma {
    type Target = apbdma::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Apbdma {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Apbdma").finish()
    }
}
#[doc = "APB DMA Register Interfaces"]
pub mod apbdma;
#[doc = "Audio Analog Digital Converter Control"]
pub struct Audadc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Audadc {}
impl Audadc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const audadc::RegisterBlock = 0x4021_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const audadc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Audadc {
    type Target = audadc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Audadc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Audadc").finish()
    }
}
#[doc = "Audio Analog Digital Converter Control"]
pub mod audadc;
#[doc = "Clock Generator"]
pub struct Clkgen {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Clkgen {}
impl Clkgen {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const clkgen::RegisterBlock = 0x4000_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const clkgen::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Clkgen {
    type Target = clkgen::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Clkgen {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Clkgen").finish()
    }
}
#[doc = "Clock Generator"]
pub mod clkgen;
#[doc = "CM4 Complex Registers (Cache, TCM, DAXI)"]
pub struct Cpu {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Cpu {}
impl Cpu {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cpu::RegisterBlock = 0x4800_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cpu::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Cpu {
    type Target = cpu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Cpu {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cpu").finish()
    }
}
#[doc = "CM4 Complex Registers (Cache, TCM, DAXI)"]
pub mod cpu;
#[doc = "Embedded security and cryptographic services"]
pub struct Crypto {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Crypto {}
impl Crypto {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const crypto::RegisterBlock = 0x400c_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const crypto::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Crypto {
    type Target = crypto::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Crypto {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Crypto").finish()
    }
}
#[doc = "Embedded security and cryptographic services"]
pub mod crypto;
#[doc = "Display Controller"]
pub struct Dc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dc {}
impl Dc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dc::RegisterBlock = 0x400a_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dc {
    type Target = dc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dc").finish()
    }
}
#[doc = "Display Controller"]
pub mod dc;
#[doc = "Digital Serial Interface Unit"]
pub struct Dsi {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dsi {}
impl Dsi {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dsi::RegisterBlock = 0x400a_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dsi::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dsi {
    type Target = dsi::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dsi {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dsi").finish()
    }
}
#[doc = "Digital Serial Interface Unit"]
pub mod dsi;
#[doc = "DSP Control Interface"]
pub struct Dsp {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dsp {}
impl Dsp {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dsp::RegisterBlock = 0x4010_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dsp::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dsp {
    type Target = dsp::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dsp {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dsp").finish()
    }
}
#[doc = "DSP Control Interface"]
pub mod dsp;
#[doc = "Fast PIO access"]
pub struct Fpio {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Fpio {}
impl Fpio {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fpio::RegisterBlock = 0x4800_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fpio::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Fpio {
    type Target = fpio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Fpio {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fpio").finish()
    }
}
#[doc = "Fast PIO access"]
pub mod fpio;
#[doc = "General Purpose IO"]
pub struct Gpio {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpio {}
impl Gpio {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio::RegisterBlock = 0x4001_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpio {
    type Target = gpio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpio {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio").finish()
    }
}
#[doc = "General Purpose IO"]
pub mod gpio;
#[doc = "Graphics Processing Unit"]
pub struct Gpu {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpu {}
impl Gpu {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpu::RegisterBlock = 0x4009_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpu::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpu {
    type Target = gpu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpu {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpu").finish()
    }
}
#[doc = "Graphics Processing Unit"]
pub mod gpu;
#[doc = "I2S ASRC Master/Slave Module"]
pub struct I2s0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2s0 {}
impl I2s0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2s0::RegisterBlock = 0x4020_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2s0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2s0 {
    type Target = i2s0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2s0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2s0").finish()
    }
}
#[doc = "I2S ASRC Master/Slave Module"]
pub mod i2s0;
#[doc = "I2S ASRC Master/Slave Module"]
pub struct I2s1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2s1 {}
impl I2s1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2s0::RegisterBlock = 0x4020_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2s0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2s1 {
    type Target = i2s0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2s1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2s1").finish()
    }
}
#[doc = "I2S ASRC Master/Slave Module"]
pub use self::i2s0 as i2s1;
#[doc = "IO Peripheral Master"]
pub struct Iom0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Iom0 {}
impl Iom0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const iom0::RegisterBlock = 0x4005_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const iom0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Iom0 {
    type Target = iom0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Iom0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Iom0").finish()
    }
}
#[doc = "IO Peripheral Master"]
pub mod iom0;
#[doc = "IO Peripheral Master"]
pub struct Iom1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Iom1 {}
impl Iom1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const iom0::RegisterBlock = 0x4005_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const iom0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Iom1 {
    type Target = iom0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Iom1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Iom1").finish()
    }
}
#[doc = "IO Peripheral Master"]
pub use self::iom0 as iom1;
#[doc = "IO Peripheral Master"]
pub struct Iom2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Iom2 {}
impl Iom2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const iom0::RegisterBlock = 0x4005_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const iom0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Iom2 {
    type Target = iom0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Iom2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Iom2").finish()
    }
}
#[doc = "IO Peripheral Master"]
pub use self::iom0 as iom2;
#[doc = "IO Peripheral Master"]
pub struct Iom3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Iom3 {}
impl Iom3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const iom0::RegisterBlock = 0x4005_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const iom0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Iom3 {
    type Target = iom0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Iom3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Iom3").finish()
    }
}
#[doc = "IO Peripheral Master"]
pub use self::iom0 as iom3;
#[doc = "IO Peripheral Master"]
pub struct Iom4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Iom4 {}
impl Iom4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const iom0::RegisterBlock = 0x4005_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const iom0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Iom4 {
    type Target = iom0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Iom4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Iom4").finish()
    }
}
#[doc = "IO Peripheral Master"]
pub use self::iom0 as iom4;
#[doc = "IO Peripheral Master"]
pub struct Iom5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Iom5 {}
impl Iom5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const iom0::RegisterBlock = 0x4005_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const iom0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Iom5 {
    type Target = iom0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Iom5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Iom5").finish()
    }
}
#[doc = "IO Peripheral Master"]
pub use self::iom0 as iom5;
#[doc = "IO Peripheral Master"]
pub struct Iom6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Iom6 {}
impl Iom6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const iom0::RegisterBlock = 0x4005_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const iom0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Iom6 {
    type Target = iom0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Iom6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Iom6").finish()
    }
}
#[doc = "IO Peripheral Master"]
pub use self::iom0 as iom6;
#[doc = "IO Peripheral Master"]
pub struct Iom7 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Iom7 {}
impl Iom7 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const iom0::RegisterBlock = 0x4005_7000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const iom0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Iom7 {
    type Target = iom0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Iom7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Iom7").finish()
    }
}
#[doc = "IO Peripheral Master"]
pub use self::iom0 as iom7;
#[doc = "I2C/SPI Slave"]
pub struct Ioslave {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ioslave {}
impl Ioslave {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ioslave::RegisterBlock = 0x4003_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ioslave::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Ioslave {
    type Target = ioslave::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ioslave {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ioslave").finish()
    }
}
#[doc = "I2C/SPI Slave"]
pub mod ioslave;
#[doc = "MCU Miscellaneous Control Logic"]
pub struct Mcuctrl {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mcuctrl {}
impl Mcuctrl {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcuctrl::RegisterBlock = 0x4002_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcuctrl::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mcuctrl {
    type Target = mcuctrl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mcuctrl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mcuctrl").finish()
    }
}
#[doc = "MCU Miscellaneous Control Logic"]
pub mod mcuctrl;
#[doc = "Multi-bit SPI Master"]
pub struct Mspi0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mspi0 {}
impl Mspi0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mspi0::RegisterBlock = 0x4006_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mspi0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mspi0 {
    type Target = mspi0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mspi0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mspi0").finish()
    }
}
#[doc = "Multi-bit SPI Master"]
pub mod mspi0;
#[doc = "Multi-bit SPI Master"]
pub struct Mspi1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mspi1 {}
impl Mspi1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mspi0::RegisterBlock = 0x4006_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mspi0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mspi1 {
    type Target = mspi0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mspi1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mspi1").finish()
    }
}
#[doc = "Multi-bit SPI Master"]
pub use self::mspi0 as mspi1;
#[doc = "Multi-bit SPI Master"]
pub struct Mspi2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mspi2 {}
impl Mspi2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mspi0::RegisterBlock = 0x4006_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mspi0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mspi2 {
    type Target = mspi0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mspi2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mspi2").finish()
    }
}
#[doc = "Multi-bit SPI Master"]
pub use self::mspi0 as mspi2;
#[doc = "PDM Audio"]
pub struct Pdm0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pdm0 {}
impl Pdm0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pdm0::RegisterBlock = 0x4020_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pdm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pdm0 {
    type Target = pdm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pdm0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pdm0").finish()
    }
}
#[doc = "PDM Audio"]
pub mod pdm0;
#[doc = "PDM Audio"]
pub struct Pdm1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pdm1 {}
impl Pdm1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pdm0::RegisterBlock = 0x4020_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pdm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pdm1 {
    type Target = pdm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pdm1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pdm1").finish()
    }
}
#[doc = "PDM Audio"]
pub use self::pdm0 as pdm1;
#[doc = "PDM Audio"]
pub struct Pdm2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pdm2 {}
impl Pdm2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pdm0::RegisterBlock = 0x4020_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pdm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pdm2 {
    type Target = pdm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pdm2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pdm2").finish()
    }
}
#[doc = "PDM Audio"]
pub use self::pdm0 as pdm2;
#[doc = "PDM Audio"]
pub struct Pdm3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pdm3 {}
impl Pdm3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pdm0::RegisterBlock = 0x4020_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pdm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pdm3 {
    type Target = pdm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pdm3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pdm3").finish()
    }
}
#[doc = "PDM Audio"]
pub use self::pdm0 as pdm3;
#[doc = "PWR Controller Register Bank"]
pub struct Pwrctrl {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwrctrl {}
impl Pwrctrl {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwrctrl::RegisterBlock = 0x4002_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwrctrl::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwrctrl {
    type Target = pwrctrl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwrctrl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwrctrl").finish()
    }
}
#[doc = "PWR Controller Register Bank"]
pub mod pwrctrl;
#[doc = "MCU Reset Generator"]
pub struct Rstgen {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rstgen {}
impl Rstgen {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rstgen::RegisterBlock = 0x4000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rstgen::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rstgen {
    type Target = rstgen::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rstgen {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rstgen").finish()
    }
}
#[doc = "MCU Reset Generator"]
pub mod rstgen;
#[doc = "Real Time Clock"]
pub struct Rtc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rtc {}
impl Rtc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rtc::RegisterBlock = 0x4000_4800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rtc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rtc {
    type Target = rtc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rtc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rtc").finish()
    }
}
#[doc = "Real Time Clock"]
pub mod rtc;
#[doc = "SDIO Control Registers"]
pub struct Sdio {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Sdio {}
impl Sdio {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const sdio::RegisterBlock = 0x4007_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sdio::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Sdio {
    type Target = sdio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Sdio {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sdio").finish()
    }
}
#[doc = "SDIO Control Registers"]
pub mod sdio;
#[doc = "Security Interfaces"]
pub struct Security {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Security {}
impl Security {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const security::RegisterBlock = 0x4003_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const security::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Security {
    type Target = security::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Security {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Security").finish()
    }
}
#[doc = "Security Interfaces"]
pub mod security;
#[doc = "Counter/Timer"]
pub struct Stimer {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Stimer {}
impl Stimer {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const stimer::RegisterBlock = 0x4000_8800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const stimer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Stimer {
    type Target = stimer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Stimer {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Stimer").finish()
    }
}
#[doc = "Counter/Timer"]
pub mod stimer;
#[doc = "Counter/Timer"]
pub struct Timer {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer {}
impl Timer {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer::RegisterBlock = 0x4000_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer {
    type Target = timer::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer").finish()
    }
}
#[doc = "Counter/Timer"]
pub mod timer;
#[doc = "Serial UART"]
pub struct Uart0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart0 {}
impl Uart0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x4001_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart0 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart0").finish()
    }
}
#[doc = "Serial UART"]
pub mod uart0;
#[doc = "Serial UART"]
pub struct Uart1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart1 {}
impl Uart1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x4001_d000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart1 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart1").finish()
    }
}
#[doc = "Serial UART"]
pub use self::uart0 as uart1;
#[doc = "Serial UART"]
pub struct Uart2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart2 {}
impl Uart2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x4001_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart2 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart2").finish()
    }
}
#[doc = "Serial UART"]
pub use self::uart0 as uart2;
#[doc = "Serial UART"]
pub struct Uart3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart3 {}
impl Uart3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x4001_f000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart3 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart3").finish()
    }
}
#[doc = "Serial UART"]
pub use self::uart0 as uart3;
#[doc = "USBPHY device register descriptions."]
pub struct Usbphy {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usbphy {}
impl Usbphy {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usbphy::RegisterBlock = 0x400b_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usbphy::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Usbphy {
    type Target = usbphy::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usbphy {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usbphy").finish()
    }
}
#[doc = "USBPHY device register descriptions."]
pub mod usbphy;
#[doc = "USB device register descriptions."]
pub struct Usb {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usb {}
impl Usb {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb::RegisterBlock = 0x400b_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Usb {
    type Target = usb::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usb {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb").finish()
    }
}
#[doc = "USB device register descriptions."]
pub mod usb;
#[doc = "Voltage Comparator"]
pub struct Vcomp {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Vcomp {}
impl Vcomp {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vcomp::RegisterBlock = 0x4000_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vcomp::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Vcomp {
    type Target = vcomp::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Vcomp {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Vcomp").finish()
    }
}
#[doc = "Voltage Comparator"]
pub mod vcomp;
#[doc = "Watchdog Timer"]
pub struct Wdt {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Wdt {}
impl Wdt {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wdt::RegisterBlock = 0x4002_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wdt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Wdt {
    type Target = wdt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Wdt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Wdt").finish()
    }
}
#[doc = "Watchdog Timer"]
pub mod wdt;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "ADC"]
    pub adc: Adc,
    #[doc = "APBDMA"]
    pub apbdma: Apbdma,
    #[doc = "AUDADC"]
    pub audadc: Audadc,
    #[doc = "CLKGEN"]
    pub clkgen: Clkgen,
    #[doc = "CPU"]
    pub cpu: Cpu,
    #[doc = "CRYPTO"]
    pub crypto: Crypto,
    #[doc = "DC"]
    pub dc: Dc,
    #[doc = "DSI"]
    pub dsi: Dsi,
    #[doc = "DSP"]
    pub dsp: Dsp,
    #[doc = "FPIO"]
    pub fpio: Fpio,
    #[doc = "GPIO"]
    pub gpio: Gpio,
    #[doc = "GPU"]
    pub gpu: Gpu,
    #[doc = "I2S0"]
    pub i2s0: I2s0,
    #[doc = "I2S1"]
    pub i2s1: I2s1,
    #[doc = "IOM0"]
    pub iom0: Iom0,
    #[doc = "IOM1"]
    pub iom1: Iom1,
    #[doc = "IOM2"]
    pub iom2: Iom2,
    #[doc = "IOM3"]
    pub iom3: Iom3,
    #[doc = "IOM4"]
    pub iom4: Iom4,
    #[doc = "IOM5"]
    pub iom5: Iom5,
    #[doc = "IOM6"]
    pub iom6: Iom6,
    #[doc = "IOM7"]
    pub iom7: Iom7,
    #[doc = "IOSLAVE"]
    pub ioslave: Ioslave,
    #[doc = "MCUCTRL"]
    pub mcuctrl: Mcuctrl,
    #[doc = "MSPI0"]
    pub mspi0: Mspi0,
    #[doc = "MSPI1"]
    pub mspi1: Mspi1,
    #[doc = "MSPI2"]
    pub mspi2: Mspi2,
    #[doc = "PDM0"]
    pub pdm0: Pdm0,
    #[doc = "PDM1"]
    pub pdm1: Pdm1,
    #[doc = "PDM2"]
    pub pdm2: Pdm2,
    #[doc = "PDM3"]
    pub pdm3: Pdm3,
    #[doc = "PWRCTRL"]
    pub pwrctrl: Pwrctrl,
    #[doc = "RSTGEN"]
    pub rstgen: Rstgen,
    #[doc = "RTC"]
    pub rtc: Rtc,
    #[doc = "SDIO"]
    pub sdio: Sdio,
    #[doc = "SECURITY"]
    pub security: Security,
    #[doc = "STIMER"]
    pub stimer: Stimer,
    #[doc = "TIMER"]
    pub timer: Timer,
    #[doc = "UART0"]
    pub uart0: Uart0,
    #[doc = "UART1"]
    pub uart1: Uart1,
    #[doc = "UART2"]
    pub uart2: Uart2,
    #[doc = "UART3"]
    pub uart3: Uart3,
    #[doc = "USBPHY"]
    pub usbphy: Usbphy,
    #[doc = "USB"]
    pub usb: Usb,
    #[doc = "VCOMP"]
    pub vcomp: Vcomp,
    #[doc = "WDT"]
    pub wdt: Wdt,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            adc: Adc::steal(),
            apbdma: Apbdma::steal(),
            audadc: Audadc::steal(),
            clkgen: Clkgen::steal(),
            cpu: Cpu::steal(),
            crypto: Crypto::steal(),
            dc: Dc::steal(),
            dsi: Dsi::steal(),
            dsp: Dsp::steal(),
            fpio: Fpio::steal(),
            gpio: Gpio::steal(),
            gpu: Gpu::steal(),
            i2s0: I2s0::steal(),
            i2s1: I2s1::steal(),
            iom0: Iom0::steal(),
            iom1: Iom1::steal(),
            iom2: Iom2::steal(),
            iom3: Iom3::steal(),
            iom4: Iom4::steal(),
            iom5: Iom5::steal(),
            iom6: Iom6::steal(),
            iom7: Iom7::steal(),
            ioslave: Ioslave::steal(),
            mcuctrl: Mcuctrl::steal(),
            mspi0: Mspi0::steal(),
            mspi1: Mspi1::steal(),
            mspi2: Mspi2::steal(),
            pdm0: Pdm0::steal(),
            pdm1: Pdm1::steal(),
            pdm2: Pdm2::steal(),
            pdm3: Pdm3::steal(),
            pwrctrl: Pwrctrl::steal(),
            rstgen: Rstgen::steal(),
            rtc: Rtc::steal(),
            sdio: Sdio::steal(),
            security: Security::steal(),
            stimer: Stimer::steal(),
            timer: Timer::steal(),
            uart0: Uart0::steal(),
            uart1: Uart1::steal(),
            uart2: Uart2::steal(),
            uart3: Uart3::steal(),
            usbphy: Usbphy::steal(),
            usb: Usb::steal(),
            vcomp: Vcomp::steal(),
            wdt: Wdt::steal(),
        }
    }
}
